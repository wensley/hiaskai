name: Auto Tag Release

permissions:
  contents: write

on:
  pull_request_target:
    types: [closed]
    branches:
      - main

jobs:
  auto-tag:
    name: Auto Tag Release
    runs-on: ubuntu-latest
    # Only trigger when PR is merged
    if: github.event.pull_request.merged == true

    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          token: ${{ secrets.GH_TOKEN }}
          # Fetch full history for proper tagging
          fetch-depth: 0

      - name: Detect release PR (version from title)
        id: release
        run: |
          PR_TITLE="${{ github.event.pull_request.title }}"
          echo "PR Title: $PR_TITLE"

          # Match "üöÄ release: v{x.x.x}" format (strict semver: x.y.z with optional -prerelease or +build)
          if [[ "$PR_TITLE" =~ ^üöÄ[[:space:]]+release:[[:space:]]*v([0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?(\+[a-zA-Z0-9.-]+)?)$ ]]; then
            VERSION="${BASH_REMATCH[1]}"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "should_tag=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Detected release PR, version: v$VERSION"
          else
            echo "should_tag=false" >> $GITHUB_OUTPUT
            echo "‚è≠Ô∏è Not a release PR"
          fi

      - name: Detect patch PR (branch first, title fallback)
        id: patch
        if: steps.release.outputs.should_tag != 'true'
        run: |
          HEAD_REF="${{ github.event.pull_request.head.ref }}"
          PR_TITLE="${{ github.event.pull_request.title }}"
          echo "Head ref: $HEAD_REF"
          echo "PR Title: $PR_TITLE"

          # Priority 1: hotfix/* or release/* branch always triggers, ignore PR title gate.
          if [[ "$HEAD_REF" == hotfix/* ]] || [[ "$HEAD_REF" == release/* ]]; then
            echo "should_tag=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Detected auto-release PR from $HEAD_REF branch (title gate bypassed)"
            exit 0
          fi

          # Priority 2: fallback to PR title prefix gate (legacy behavior).
          if echo "$PR_TITLE" | grep -qiE '^(üíÑ[[:space:]]*)?style(\(.+\))?:|^(‚ú®[[:space:]]*)?feat(\(.+\))?:|^(üêõ[[:space:]]*)?fix(\(.+\))?:|^(‚ôªÔ∏è[[:space:]]*)?refactor(\(.+\))?:|^((üêõ|ü©π)[[:space:]]*)?hotfix(\(.+\))?:|^(üë∑[[:space:]]*)?build(\(.+\))?:'; then
            echo "should_tag=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Detected patch PR from title prefix gate"
          else
            echo "should_tag=false" >> $GITHUB_OUTPUT
            echo "‚è≠Ô∏è Not a patch PR (neither hotfix/release branch nor style/feat/fix/refactor/hotfix/build title prefix)"
          fi

      - name: Prepare main branch
        if: steps.release.outputs.should_tag == 'true' || steps.patch.outputs.should_tag == 'true'
        run: |
          git checkout main
          git pull --rebase origin main

      - name: Resolve patch version (patch bump)
        id: patch-version
        if: steps.patch.outputs.should_tag == 'true'
        run: |
          CURRENT_VERSION="$(node -p "require('./package.json').version")"
          echo "Current version: ${CURRENT_VERSION}"

          # Coerce to stable base (e.g. 2.0.0-beta.1 -> 2.0.0), then bump patch (-> 2.0.1)
          BASE_VERSION="$(npx -y semver@7 "${CURRENT_VERSION}" -c)"
          if [ -z "${BASE_VERSION}" ]; then
            echo "‚ùå Invalid version in package.json: ${CURRENT_VERSION}"
            exit 1
          fi

          NEXT_VERSION="$(npx -y semver@7 -i patch "${BASE_VERSION}")"
          echo "üì¶ Patch version: ${NEXT_VERSION}"
          echo "version=${NEXT_VERSION}" >> "$GITHUB_OUTPUT"

      - name: Set context (release)
        if: steps.release.outputs.should_tag == 'true'
        run: |
          echo "SHOULD_TAG=true" >> $GITHUB_ENV
          echo "KIND=release" >> $GITHUB_ENV
          echo "VERSION=${{ steps.release.outputs.version }}" >> $GITHUB_ENV

      - name: Set context (patch)
        if: steps.patch.outputs.should_tag == 'true'
        run: |
          echo "SHOULD_TAG=true" >> $GITHUB_ENV
          echo "KIND=patch" >> $GITHUB_ENV
          echo "VERSION=${{ steps.patch-version.outputs.version }}" >> $GITHUB_ENV

      - name: Check if tag already exists
        if: env.SHOULD_TAG == 'true'
        id: check-tag
        run: |
          VERSION="${{ env.VERSION }}"
          if git rev-parse "v$VERSION" >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Tag v$VERSION already exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "‚úÖ Tag v$VERSION does not exist, can create"
          fi

      - name: Bump package.json version (before tagging)
        if: env.SHOULD_TAG == 'true' && steps.check-tag.outputs.exists == 'false'
        id: bump-version
        run: |
          VERSION="${{ env.VERSION }}"
          KIND="${{ env.KIND }}"
          echo "üìù Bumping package.json version to: $VERSION"

          # Validate VERSION is strict semver before writing
          if ! npx -y semver@7 "$VERSION" >/dev/null 2>&1; then
            echo "‚ùå Invalid semver version: $VERSION"
            exit 1
          fi

          # Configure git
          git config --global user.name "lobehubbot"
          git config --global user.email "i@lobehub.com"

          # Update package.json using Node.js
          node -e "
            const fs = require('fs');
            const pkg = JSON.parse(fs.readFileSync('./package.json', 'utf8'));
            const target = '$VERSION';
            if (pkg.version === target) {
              console.log('‚úÖ package.json already at version', target);
              process.exit(0);
            }
            pkg.version = target;
            fs.writeFileSync('./package.json', JSON.stringify(pkg, null, 2) + '\n');
            console.log('‚úÖ package.json updated to', target);
          "

          # Commit changes (if any) and push
          git add package.json
          COMMIT_MSG="üîñ chore(release): release version v$VERSION [skip ci]"
          git commit -m "$COMMIT_MSG" || echo "Nothing to commit"
          git push origin HEAD:main

          # Output the SHA we will tag
          echo "tag_sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT

      - name: Create Tag
        if: env.SHOULD_TAG == 'true' && steps.check-tag.outputs.exists == 'false'
        run: |
          VERSION="${{ env.VERSION }}"
          KIND="${{ env.KIND }}"
          echo "üè∑Ô∏è Creating tag: v$VERSION"

          # Tag the bumped version commit SHA (not the PR merge commit SHA)
          TAG_SHA="${{ steps.bump-version.outputs.tag_sha }}"

          # Create annotated tag with single line message
          git tag -a "v$VERSION" "$TAG_SHA" -m "üöÄ release: v$VERSION | PR #${{ github.event.pull_request.number }} | Author: ${{ github.event.pull_request.user.login }}"

          # Push tag
          git push origin "v$VERSION"

          echo "‚úÖ Tag v$VERSION created successfully!"

      - name: Create GitHub Release
        if: env.SHOULD_TAG == 'true' && steps.check-tag.outputs.exists == 'false'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ env.VERSION }}
          name: üöÄ Release v${{ env.VERSION }}
          body: |
            ## üì¶ Release v${{ env.VERSION }}

            This release was automatically published from PR #${{ github.event.pull_request.number }}.

            ### Changes
            See PR description: ${{ github.event.pull_request.html_url }}

            ### Commit Message
            ${{ github.event.pull_request.body }}
          draft: false
        env:
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}

      - name: Output result
        run: |
          if [ "${{ env.SHOULD_TAG }}" == "true" ]; then
            if [ "${{ steps.check-tag.outputs.exists }}" == "true" ]; then
              echo "‚ö†Ô∏è Result: Tag v${{ env.VERSION }} already exists, skipping creation"
            else
              echo "‚úÖ Result: Tag v${{ env.VERSION }} created successfully!"
            fi
          else
            echo "‚ÑπÔ∏è Result: Not a release/patch PR, no tag created"
          fi
